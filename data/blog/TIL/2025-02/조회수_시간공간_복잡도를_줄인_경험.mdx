---
title: '조회수'
date: '2025-08-05'
tags: ['프로젝트', 'Redis', '조회수', '시간복잡도', '공간복잡도']
draft: false
summary: '조회수'
---


앞서 작성한 「Redis로 조회수, 인기글 기능을 도입하며 겪은 트러블슈팅 경험」에서는 API 응답 지연, Redis 과다 호출, 정렬 비용 등의 실시간 처리 병목을 해결하는 데 초점을 맞췄다면,

이번 글에서는 근본적으로 “시간/공간 복잡도 관점에서의 구조 개선을 중심으로 장기적으로 발생할 수 있는 성능 저하와 비용 증가 방지하기 위한 구조적 리팩토링을 작성합니다.

## 상황

서비스에서는 게시글 상세 페이지를 조회할 때마다 즉시 조회수를 증가시키는 기능을 제공하고 있었다.

이 부분을 성능 측면으로 개선하기 위해, 조회수 데이터를 RDB가 아닌 Redis에 우선 저장하고 일정 주기마다 RDB로 동기화하는 구조를 도입했다.

구현 초기에는 Redis에 view:article:{id} 형태의 키로 조회수를 저장하고, 중복 조회 방지를 위해 viewed:members:{articleId} 형태의 Set 키에 사용자 ID를 함께 기록했다.

TTL을 활용하여 일정 시간이 지나면 Redis 키가 자동으로 제거되도록 구성함으로써, 메모리 사용량을 조절할 수 있다고 판단했다.

그리고 인기글 기능은 RDB에 저장된 누적 조회수 기준으로 정렬되도록 구현했으며, Redis는 일시적인 캐시와 중복 방지를 위한 도구로만 사용하는 구조였다.

### 이 방식은 트래픽이 적을 때는 문제 없이 작동했다.

하지만 서비스 배포하고 부하 테스트를 진행해보니, 수천 건 이상이라면 구조적인 문제가 드러나기 시작했다.

- Redis에 생성되는 키의 수가 게시글 수 × 사용자 수로 폭증했고,
- TTL만으로는 Redis 메모리 사용량을 안정적으로 제어할 수 없는 문제도 발생했다.

무엇보다 시간이 지날수록 Redis의 메모리 사용량이 증가했고,

캐시 삭제 주기를 통제할 수 없는 구조는 공간 복잡도를 예측 불가능하게 만들었다.

인기글 순위는 실시간 사용자 경험을 반영하지 못하고 정합성도 유지되지 않는 상태가 되었다.

그리하여 조회수 시스템을 시간 / 공간 복잡도 관점에서 리팩토링할 필요하다고 생각했다.

<br/>

## 원인

조회수 시스템은 조회 요청이 들어올 때마다 Redis에 view:article:{id} 키의 값을 증가시키는 방식으로 구성되었다.

동시에, 중복 조회를 방지하기 위해 viewed:members:{articleId} 키에 사용자 ID를 Set으로 저장했다.

키는 Redis의 Set 자료구조를 사용해 구현됐고, 동일 사용자가 중복으로 조회할 경우 Set의 중복 불가 특성을 활용해 필터링할 수 있었다.

이 구조는 단순하게 구현할 수 있었고, 초기 트래픽에서는 문제를 일으키지 않았다.

하지만 실제 운영 환경에서 밑에 내용들의 문제 조건이 겹치면서, 구조적으로 위험한 설계라는 점이라고 생각이 들었다.

### Redis에 저장되는 키 수가 기하급수적으로 증가함

Redis에는 게시글 ID 단위로 Set 키가 생성되었고, 해당 Set에는 조회한 사용자 ID가 누적되었다.

예를 들어, viewed:members:1001 키는 1001번 게시글을 조회한 모든 사용자의 ID를 저장한다.

- 게시글 수가 1만 개일 경우, Set 키도 1만 개 생성
- 각 게시글에 하루 평균 1천 명이 접근한다면 → 하루에만 총 1천만 개의 사용자 ID가 Redis Set에 삽입됨

게다가 TTL로 자동 만료를 설정했지만, TTL은 고정된 시간이 지나야 만료되며,

사용자의 접근 패턴에 따라 키의 수명은 달라지고, 결국 시스템이 TTL 만료 시점을 통제하기 어렵다.

### TTL 기반 삭제 전략의 한계

각 Set 키에는 TTL을 적용했지만 일부 게시글은 자주 조회되어 TTL이 계속 갱신되었고, 일부는 조회가 드물어 삭제되었다.

- 자주 조회되는 게시글의 Set은 TTL 갱신으로 Redis에 계속 남아 있게 됨
- 드물게 조회되는 게시글은 TTL이 만료되며 자연스럽게 삭제됨

즉, 자주 사용되는 키는 사실상 삭제되지 않는 고정 메모리로 남게 되었고, TTL 기반 구조가 예측 불가능한 공간 복잡도를 가지게 만들었다.

시간이 지날수록 Redis 메모리 사용량이 줄어들지 않고, 오히려 누적되는 문제가 생겼다.

### 인기글 정렬 기준의 일관성 부족

조회수는 Redis에 먼저 기록되고, 주기적으로 DB로 동기화되는 구조였다.

그런데 인기글 기능은 DB의 조회수를 기준으로 정렬하고 있었기 때문에 문제가 발생했다.

- 사용자가 실제로 많이 본 게시글이 인기글에 반영되지 않음
- 반대로, 예전에 조회수가 많았지만 지금은 인기가 없는 게시글이 상단에 노출됨

즉, 인기글 기능이 실제 사용자 경험과 정렬 기준 사이에 문제가 생겼다.

이 불일치는 Redis와 DB 간 동기화 간격이 클수록 문제가 커졌고, 실시간성과 정확성 사이의 문제로 이어졌다.

<br/>

## 해결

### 중복 조회 방지 방식을 간소화하면서 Redis 키 수 줄이기

기존에는 게시글마다 viewed:members:{articleId} 형태의 Set 키를 만들고, 사용자의 ID를 삽입해 중복을 방지했지만, 이제는 이 구조를 유지하면서도 TTL을 명확히 관리하고, 필요한 데이터만 남기는 방향으로 변경했다.

```java
String key = RedisKey.getViewedMembersKey(articleId);
Long added = redisTemplate.opsForSet().add(key, String.valueOf(memberId));

if (added != RedisConstants.REDIS_SET_ADD_SUCCESS) {
    return;
}
redisTemplate.expire(key, RedisConstants.DUPLICATE_PREVENTION_TTL, TimeUnit.SECONDS);
```

- 중복일 경우 바로 return하여 Redis 공간 낭비를 줄였고,
- TTL은 일정 시간만 유지되며, 그 이후에는 중복 체크를 하지 않도록 설계해 키 수명을 제한했다.
- TTL 갱신이 반복되는 키를 억제함으로써, 자주 조회되는 게시글이 Redis에서 무한히 살아남는 문제를 해결했다.

### 집계용 Set 관리

Set 기반 사용자 ID 누적 구조와 별개로, 순수한 조회수는 view:article:{id} 키에만 저장된다.

```java
redisTemplate.opsForValue().increment(RedisKey.getArticleViewKey(articleId));
redisTemplate.opsForSet().add(RedisKey.articlesSaveDbKey(), articleId.toString());
```

그리고 articles:save:db 키에 이 게시글 ID를 추가함으로써, DB에 반영할 대상만 추적하도록 분리했다.

- 무조건 모든 게시글의 조회수를 동기화하지 않고, 변경이 있었던 게시글만 추적
- view:article:{id} → 단일 Redis String이므로 공간 복잡도가 낮음
- articles:save:db → Redis Set이지만, 조회수 증가한 게시글만 남김

### 조회수 동기화는 별도 스케줄러에서 일괄 처리

조회수가 DB로 동기화되는 시점은 @Scheduled를 통해 주기적으로 호출된다.

```java
@Scheduled(fixedRate = RedisConstants.SYNC_INTERVAL_MILLIS)
public void syncViewCounts() {
    articleViewService.bulkUpdateViewCounts();
}
```

1. articles:save:db Set에서 업데이트 대상 게시글 ID 목록을 가져옴
2. 각 게시글에 대해 Redis에서 조회수를 조회
3. 조회수가 존재하는 경우에만 DB에 반영 (bulkAddViewCount)
4. Redis의 조회수 키, 저장 대상 키를 삭제

```java
redisViewCounts.forEach(articleRepository::bulkAddViewCount);
articleRepository.flush();

for (Long articleId : redisViewCounts.keySet()) {
    redisTemplate.delete(RedisKey.getArticleViewKey(articleId));
    redisTemplate.opsForSet().remove(RedisKey.articlesSaveDbKey(), articleId.toString());
}
```

- DB 반영 대상 최소화: 변경이 없던 게시글은 동기화하지 않음
- 정합성 확보: Redis → DB 반영 후, Redis 키는 제거
- 공간 복잡도 제어: TTL 만료를 기다리지 않고, 불필요한 Redis 키는 제거

### 인기글 정렬도 Redis 기준이 아닌 RDB 기준으로 통일

정렬 기준이 Redis와 DB로 분리되어 있던 구조에서 → DB 기준으로 인기글을 계산하고 Redis에는 정렬된 결과만 저장한다.

```java
public void updateRedisTopArticles() {
    List<Article> topArticles = articleRepository.findTopByViews(...);

    redisTemplate.delete(key);
    for (Article article : topArticles) {
        redisTemplate.opsForList().rightPush(key, article.getIdAsString());
    }
}
```

- Redis ZSet 대신 Redis List 사용으로 정렬된 ID만 저장
- Redis는 정렬 데이터를 빠르게 조회하기 위한 캐시일 뿐, 기준은 오직 DB에 둠
- 인기글은 DB 기준 → Redis → 클라이언트 응답까지 일관되게 연결됨

<br/>

## 결과

### Redis 공간 복잡도 개선 O(N×M) → O(K)

![image.png](/static/images/image239.png)

기존 구조에서는 게시글 수 × 사용자 수만큼의 Set 키가 Redis에 생성되었고, TTL이 반복 갱신되며 메모리 누수가 발생했다.

리팩토링 이후에는 중복 방지 키의 TTL을 제어하고, 조회수 변경이 있는 게시글만을 추적 대상으로 분리함으로써 Redis 키 수를 게시글 수 수준으로 고정시켰다.

- TTL이 반복 갱신되는 문제 제거 → 자주 조회되는 게시글도 지속적으로 메모리 차지하지 않음
- 중복 체크는 일정 시간 유지 → Set 키 수명 제한
- 실제 Redis 메모리 사용량도 4.6MB 수준으로 개선

| 항목 | 개선 전 | 개선 후 |
| --- | --- | --- |
| 게시글 수 | 1,000개 | 1,000개 |
| 사용자 수 | 1,000명 | 1,000명 |
| Redis 키 수 | 최대 100,000개 수준 | 1,000개 수준 |
| Redis 메모리 사용량 | 약 20~30MB 이상
(TTL 반복 갱신 시 증가) | 4.6MB |
| TTL 부하 | 지속적 TTL 갱신
(트래픽 증가 시 Redis 부하) | 최초 1회 설정 후 유지 |

### DB 동기화 범위 시간 복잡도 개선 O(N) → O(K)

![image.png](/static/images/image240.png)

기존 구조에서는 전체 게시글(N)을 주기적으로 스캔하면서, 조회수 변경 여부와 관계없이 모든 게시글에 대해 쓰기 연산을 수행했다.

트래픽이 증가할수록 불필요한 DB 부하로 이어졌고, 실제 변경이 없는 게시글에도 UPDATE 쿼리가 실행되는 문제가 있었다.

리팩토링 이후에는 Redis Set(articles:save:db)을 활용해 조회수 변경이 감지된 게시글(K)만 추적하고,

이들에 대해서만 일괄 처리(Bulk Update) 방식으로 DB에 저장함으로써 I/O 부하를 크게 줄일 수 있었다.

- O(N) 전체 순회 → O(K) 변경된 게시글만 반영 (K ≪ N)
- Redis 조회 → DB 저장 → Redis 키 삭제 → 일괄 처리로 시간 단축

| 항목 | 개선 전 | 개선 후 |
| --- | --- | --- |
| 게시글 수 (N) | 1,000개 | 1,000개 |
| 변경 감지 게시글 수 (K) | 관계없이 전체 스캔 | 평균 250개 (25% 수준) |
| DB 쓰기 요청 수 | 1,000건 / 주기 | 250건 / 주기 |
| 예상 I/O 감소율 | - | 약 75% 감소 |
| 처리 방식 | 게시글별 개별 UPDATE | Bulk UPDATE + Redis 키 일괄 삭제 |
| 성능 테스트 결과 | 1,000개 처리 시 수백 ms 소요 | 250개 처리 시 약 0.2초 내외 |

### 인기글 정렬 O(logN) → O(1)

![image.png](/static/images/image241.png)

기존 구조에서는 Redis Sorted Set(ZSet)을 활용해 인기글을 실시간으로 정렬했으며, 조회수 증가마다 ZINCRBY 연산을 수행하며 성능 병목 가능성이 존재했다.

리팩토링 이후에는 인기글 정렬을 RDB에서 주기적으로 계산하고, 그 결과만 Redis List로 저장하여, 정렬 로직을 DB에 위임하고 Redis는 단순 캐시 역할만 수행하도록 변경했다.

- Redis는 정렬된 인기글 ID 리스트만 보관
- 클라이언트는 API 요청 시 O(1)로 인기글 응답 가능
- 정렬 기준(RDB 기준) 일원화로 정합성 향상 및 중복 연산 제거
- 실시간 정렬 로직 제거 → Redis ZSet 제거, Redis 연산량 감소

| 항목 | 개선 전 | 개선 후 |
| --- | --- | --- |
| 정렬 방식 | Redis ZSet 기반 정렬  | RDB 정렬 결과를 Redis List로 캐싱 |
| 정렬 비용 | O(logN) + 트래픽 증가 시 연산량 증가 | O(1) – 정렬 없이 조회만 수행 |
| Redis 연산량 | 다수의 ZINCRBY, ZREVRANGE | 단순 LRANGE |
| 데이터 일관성 | Redis와 RDB 간 기준 혼재 | RDB 기준으로 정렬 일원화 |
| 인기글 데이터 크기 | 게시글 수에 따라 증가 (N개) | Top 5 게시글 ID만 유지 |

