---
title: 'Redis로 조회수, 인기글 기능을 도입하며 겪은 트러블슈팅 경험'
date: '2025-07-23'
tags: ['프로젝트', 'Redis', '조회수', '인기글', '캐싱']
draft: false
summary: '조회수 시스템을 Redis 기반으로 리팩토링하며 조회수 동기화 속도 83%, 인기글 API 응답 속도 42% 개선한 경험'
---

### Introduction

<TOCInline toc={props.toc} exclude="Introduction" />

## 상황

초기에는 단순히 DB의 조회수 컬럼을 증가시키는 방식이었기 때문에, 같은 사용자가 새로고침만 반복해도 조회수가 계속 올라갔고, 트래픽이 몰릴 경우 DB에 부담이 있을 수 있는 구조였다.

인기글 기능 또한 DB에서 조회수를 기준으로 정렬하여 상위 5개를 조회하는 방식이라 실시간성이 부족하여 정확한 인기글 반영이 어려웠다.

무엇보다 조회수 증가와 인기글 조회가 완전히 분리된 구조였기 때문에, 조회수가 늘어나도 인기글 순위에는 즉각 반영되지 않았고,

두 기능을 연동하거나 확장하는 데에 구조적인 제약이 많았다.

<br/>

## 문제

Redis를 기반으로 구조를 변경한 후, 다음과 같은 문제들을 겪었다.

### `view:article:*` 패턴으로 Redis 키를 조회할 때 성능 저하 발생

![image.png](/static/images/image233.png)

Redis를 기반으로 조회수 기능을 구현하면서, 동기화 대상 키를 찾는 방식에 대해 잘못된 가정을 하고 있었다.

처음에는 `view:article:1`, `view:article:2`와 같이 키가 일관된 prefix로 구성되어 있으니,

`view:article:*` 와일드카드 패턴으로 조회하면 Redis 내부에서도 효율적으로 이 키들만 탐색할 것이라 생각했다.

예를 들어 `view:article:`로 시작하는 키만 빠르게 찾을 것이다라는 착각이 있었던 것이다.

하지만 실제로 Redis에서 KEYS `view:article:*` 명령을 실행하면, 전체 키 공간을 전수 스캔하며, 모든 키에 대해 매칭을 수행한다.

```java
- 저장된 키들: view:article:1, view:article:2, article:top:list, user:session:abc, ...
- KEYS view:article:* 명령 실행 시
  => Redis는 모든 키를 순회하며, view:article:* 패턴과 매칭되는지 확인
  => O(N) 시간 복잡도, 대량의 키가 존재할수록 Redis 성능 저하
```


#### 잘못 생각했던 것.

> 어차피 중복 체크도 다 끝났고, 조회수도 이미 증가한 애들이니까,
>

> 굳이 하나하나 따로 관리할 필요 없이 view:article:*로 전체 조회해서 DB에 반영해버리면 되지 않나?
>

하지만 실제 운영 환경에서 키 수가 많아지자,

이 방식은 Redis의 응답 지연과 CPU 부하를 유발하는 병목 지점이 되었다.

### 인기글 조회 로직에서 반복적인 Redis 조회로 성능 비효율 발생

![image.png](/static/images/image234.png)

초기에는 인기글 API는 Redis ZSet을 활용해 조회수가 높은 게시글 ID Top 5를 먼저 조회한 뒤,

각 게시글의 Redis 조회수를 별도로 조회해 DB 값과 합산하는 방식으로 구성되어 있었다.

인기글 API는 Redis ZSet을 이용해 조회수가 높은 게시글 ID Top 5를 조회한 뒤,

각 게시글의 조회수를 다시 Redis에서 별도로 조회해 DB 값과 합산하는 방식으로 구현했다.

1. ZSet에서 인기글 ID 조회 → Redis 요청 (1회)

```java
ZREVRANGE article:top:list 0 4
```

1. 각 게시글의 조회수 조회 → Redis 요청 (5회)

```java
GET article:view:1
GET article:view:2
GET article:view:3
GET article:view:4
GET article:view:5
```

결과적으로, 인기글 API 요청 한 번마다 최소 6회의 Redis 네트워크 호출이 발생했다.

트래픽이 많아질수록 Redis 부하와 응답 지연 가능성이 커지는 구조였다.

또한, 조회수 데이터가 DB와 Redis에 분산되어 있어 이를

합산하고 응답을 조립하는 과정 자체도 복잡하고 비효율적이었다.

### Redis 키 구조와 로직 분리가 불명확했던 설계

처음에는 조회수 기능에는 여러 Redis 키가 존재했는데, 이 키들의 관리 주체가 명확히 분리되어 있지 않았다.

```java
private static final String ARTICLE_RANKING_KEY = "ranking:article:";
private static final String CACHED_TOP_RANKING_KEY = "ranking:article:top5:cached";
private static final String ARTICLE_LIKE_LOCK_PREFIX = "lock:article:like:";
private static final String ARTICLE_VIEW_TRACKING_KEY_SET = "view:article:keys";
private static final String ARTICLE_MEMBER_VIEW_PATTERN = "viewed:article:%s:member:%s";
```

비슷비슷해 보이는 키가 많다…

다양한 키와 역할이 존재하는데도, 관리하는 코드가 서비스, 스케줄러, 유틸 클래스 등 여러 위치에 산재해 있어 추후 유지보수 시 어디서 어떤 로직이 실행되고 있는지 직관적으로 파악하기 어려웠다.

스케줄러에서 조회수 집계를 처리할 때, 어떤 키를 삭제하고 어떤 기준으로 랭킹을 갱신하는지 확인하려면 여러 클래스를 동시에 열어봐야 했고, 테스트 코드도 따로 존재하지 않았다.

버그가 발생해도 원인 추적이 어려웠고, 새로운 기능을 추가하거나 수정하려 할 때도 불편함이 생겼다.

<br/>

## 원인

### Redis 와일드카드 패턴에 대한 오해

처음에는 `view:article:1`, `view:article:2`처럼 키가 정형화되어 있으니 `view:article:*`로 Redis에서 조회할 수 있을 거라 생각했다. 하지만 Redis 내부 동작 방식에 대한 오해였다.

- KEYS `view:article:*` 명령은 Redis가 전체 키 공간을 순회하며 매칭을 수행하는 O(N) 연산이다.
- 키 수가 많아질수록 Redis의 응답 시간과 CPU 사용량이 증가하고, 운영 환경에서 성능 병목을 초래한다.
- 즉, 조회수 동기화를 위한 키 필터링 로직이 아니라 전체 키 스캔 기반이었기 때문에 구조적으로 위험했다.

이 문제는 단순히 코드가 잘못된 것이 아니라, Redis 키 탐색 방식 자체에 대한 이해 부족에서 생긴 오류 설계였다.

### 인기글 API에서의 반복적 Redis 요청

ZSet으로 인기글 ID를 가져오고, 각 게시글의 조회수를 Redis에서 따로 GET 요청하여 DB 값과 합산하는 구조였다.

- 초기 구조는 조회수와 랭킹 데이터가 물리적으로 분리되어 있어 발생한 문제였다.
- 조회수는 `article:view:{id}`에, 랭킹은 `article:top:list` ZSet에 저장되는데, 이 둘이 분리되어 있다 보니 조회 → 조회수 조회 → 합산 → 응답 조립이라는 흐름이 발생했다.
- 게시글 5개에 대해 총 6회의 Redis 네트워크 요청이 발생하며, 트래픽 증가에 따라 Redis I/O 병목이 생길 수밖에 없는 구조였다.
- 실시간 조회수 반영과 인기글 정렬이라는 두 기능이 연결되어 있으면서도, 실제로는 분산된 상태로 구현되어 있기 때문이다.

### Redis 키와 로직 책임 분리 실패

처음에는 Redis 키 네이밍 규칙도 명확하지 않았고, 관련 로직도 여러 클래스에 흩어져 있었다.

조회수 키 생성은 RedisKey 클래스, 랭킹 키는 스케줄러 내부 상수, 중복 방지 키는 또 다른 서비스 내부에서 하드코딩된 문자열로 사용됐다.

결과적으로, 단일 책임 원칙(SRP)이 지켜지지 않아 응집도가 떨어졌던 것이다.

<br/>

## 해결

### 동기화 대상 키 관리를 Set으로 분리하여 KEYS 명령 제거

초기에는 조회수 증가 시점에 Redis에 다음과 같은 키가 생성되고 있었다.

```java
view:article:1
view:article:2
view:article:3
...
```

이 키들은 Redis 내에 일정 기간 유지되며, 실제 DB에는 비동기적으로 반영되도록 설계했는데, 

문제는 어떤 게시글이 DB로 동기화되어야 하는지를 판단할 기준이 없었다는 점이었다.

그 결과, 조회수 동기화 스케줄러는 매 실행마다 밑에 같은 방식으로 동기화 대상을 찾아야 했다

```java
// 잘못된 방식
Set<String> keys = redisTemplate.keys("view:article:*");
```

이 코드는 `view:article:`로 시작하는 모든 키를 찾기 위해 와일드카드 패턴을 사용하고 있지만,

Redis의 KEYS 명령어는 전체 키 공간을 전수 스캔 하며 매칭을 수행하는 구조이다.

Redis 내에 수천개의 키가 존재하게 되면, 이 작업은 O(N) 복잡도를 가지며,

성능 저하 및 Redis CPU 사용량 급증의 원인이 될 수 있다.

Redis 전반에 부하를 일으키는 병목 지점이라고 생각했다.

조회수 동기화 대상이 되는 게시글 ID만 별도로 Set 자료구조에 보관하도록 설계를 변경했다.

```java
// 조회수 증가 시점에 다음과 같은 작업을 함께 수행
redisTemplate.opsForValue().increment("view:article:" + articleId);
redisTemplate.opsForSet().add("articles:save:db", articleId);
```

조회수가 증가할 때마다 해당 게시글 ID를 `articles:save:db`라는 Redis Set에 추가 Set은 단순한 중복 허용 없이 집합(Set) 형태로 ID만 관리되기 때문에 조회 시 중복 걱정 없고, 삽입/조회 연산도 평균 O(1) 성능을 보장한다.

그리하여 스케줄러는 전체 키를 순회하지 않고, 이 Set에 포함된 게시글 ID만 선택적으로 조회한다.

```java
// 설명하기 위한 예시 코드
Set<String> articleIds = redisTemplate.opsForSet().members("articles:save:db");

for (String id : articleIds) {
    String key = "view:article:" + id;
    String count = redisTemplate.opsForValue().get(key);
    // DB 반영 및 키 삭제 로직 수행
}
```

### 인기글 API에서 Redis 반복 조회 제거 및 정렬 캐싱

![image.png](/static/images/image235.png)

초기에는 인기글 정렬 기능을 Redis 없이 DB 단독으로 처리하거나, 조회수 기준 정렬을 실시간으로 반복 계산하는 방식이었다.

하지만 이 방식은 문제가 있었다.

- 트래픽 증가 시마다 정렬 쿼리가 DB에 부담을 준다.
- 실시간 조회수는 Redis에 저장되어 있으나, 인기글 정렬에 반영되기까지는 지연이 존재한다.
- 결과적으로 정렬 기준이 일관되지 않거나, 매 요청마다 부하가 커지는 구조인 것이다.

```java
이 문제를 해결하기 위해 인기글 랭킹을 실시간 계산 → 주기적 캐싱으로 구조 변경하였다.
```

- 게시글 조회수는 Redis에 저장 (예: `article:view:{id}`)
- 인기글 랭킹은 조회수 기준으로 주기적으로 DB에서 계산
- 정렬된 인기글 ID 목록을 Redis List에 캐싱 (예: `article:top:list`)
- 이후 API는 Redis List에 저장된 ID 목록을 기준으로 정렬된 게시글 정보를 반환

```java
// 스케줄러에서 캐싱
List<Article> topArticles = articleRepository.findTopByViews(PageRequest.of(0, 5));
redisTemplate.delete("article:top:list");

for (Article article : topArticles) {
    redisTemplate.opsForList().rightPush("article:top:list", article.getIdAsString());
}

// API 조회 로직
List<String> cachedIds = redisTemplate.opsForList().range("article:top:list", 0, 4);
List<Article> articles = articleRepository.findAllById(cachedIds);
```

인기글 정렬 정보를 Redis에 주기적으로 저장함으로써, API 요청 시 Redis에서 ID 목록만 조회한 후, 최소한의 DB 조회로 응답을 구성하게 되었다.

### Redis 접근 로직을 모듈화하여 유지보수성 개선

기존에는 Redis 키가 여러 개 존재했지만, 명확한 네이밍 규칙이나 관리 주체 없이

서비스, 스케줄러, 유틸 클래스 등에 로직이 산발적으로 분산되어 있었다.

- 어떤 Redis 키가 사용되고 있는지 전체 흐름을 파악하기 어려움
- 잘못된 키 사용 시 자동 검증 수단이 없음
- 새로운 기능 추가 시 키 이름을 일관되게 만들기 어려움

그리하여 다음과 같은 구조 개선을 적용했다.

RedisKey 유틸 클래스를 중심으로 키 생성을 통일

- 모든 Redis 키는 RedisKey라는 전용 클래스에서만 생성하도록 규칙을 정하고,
- 상수를 통해 키 prefix를 명시한 후, 전용 메서드를 통해 키 생성

```java
public class RedisKey {

    private static final String ARTICLE_VIEW = "article:view:";
    private static final String ARTICLE_TOP_LIST = "article:top:list";
    private static final String ARTICLE_VIEWED_MEMBERS = "article:viewed:members:";
    private static final String ARTICLES_SAVE_DB = "articles:save:db";

    public static String getArticleViewKey(Long articleId) {
        return ARTICLE_VIEW + articleId;
    }

    public static String getViewedMembersKey(Long articleId) {
        return ARTICLE_VIEWED_MEMBERS + articleId;
    }

    public static String getTopArticleListKey() {
        return ARTICLE_TOP_LIST;
    }

    public static String articlesSaveDbKey() {
        return ARTICLES_SAVE_DB;
    }
}
```

이제 Redis 키를 사용할 때는 문자열 하드코딩 없이 위 메서드만 사용하도록 변경했다.

역할에 따라 Redis 접근 로직을 Service로 분리

- ArticleViewService: 조회수 증가, 중복 방지, 동기화 대상 관리 등 조회수 중심 로직 전담
- ArticleRankingService: 인기글 ID 캐싱, 랭킹 리스트 조회 등 랭킹 중심 로직 전담

→ 각 서비스는 자신이 사용하는 Redis 키만 접근하고, 서로의 책임 범위를 침범하지 않도록 구조를 분리했다.

<br/>

## 결과

### Redis 서버의 평균 CPU 사용률이 17% 감소

![image.png](/static/images/image236.png)

기존에는 조회수 동기화 스케줄러가 실행될 때마다 Redis에서 전체 키를 탐색하는 작업으로 인해, 스케줄러 실행 시점에 CPU 사용률이 60~80%까지 치솟는 현상이 발생하고는 했다.

구조 개선 이후에는 전체 키를 탐색하는 방식 대신, 동기화 대상 게시글 ID만을 조회하는 방식으로 변경되었고, 그 결과 불필요한 연산이 제거되면서 평균 CPU 사용률은 25% 수준으로 낮아졌다. 전체적으로 17%의 평균 CPU 사용률 감소한걸 확인할 수 있었다.

### 조회수 동기화 처리 속도 83% 단축

![image.png](/static/images/image237.png)

기존 구조에서는 조회수 동기화를 위해 Redis의 모든 조회수 키를 KEYS 명령어로 탐색하고, 각 키의 값을 조회한 뒤 데이터를 정제해 데이터베이스에 반영했다.

이 방식은 대상이 많을수록 키 탐색 → 값 조회 → 가공 → DB 저장이라는 복잡한 작업이 계속해서 수행되어 전체 처리 시간이 증가하는 구조였다. 실제로 3초 이상 소요되는 경우도 자주 발생했다.

반면 개선된 구조에서는 조회수가 증가한 게시글 ID만 Set에 저장하고, 스케줄러는 해당 ID만 조회해 필요한 데이터만 반영한다. 즉, 전체 키를 전수 탐색하지 않고 정확한 대상만 처리하는 방식으로 변경된 것이다.

그 결과, 전체 동기화 처리가 0.5초 이내에 완료되었고, 최대 처리 시간 기준으로 약 83% 단축되었다.

### 인기글 Top5 API 응답 42% 단축

![image.png](/static/images/image238.png)

기존 인기글 API는 Redis ZSet에서 인기글 ID를 가져온 후, 각 ID에 대해 Redis GET 요청을 반복하여 조회수를 조회하고 응답을 구성하는 구조였다.

이 과정에서 요청 1건당 최대 6회의 Redis 호출이 발생하며, 트래픽이 많을 경우 평균 응답 시간이 약 0.52초까지 증가하는 현상이 있었다.

개선된 구조에서는 인기글 목록과 조회수를 Redis List로 통합 캐싱하고, 단일 Redis GET 요청만으로 응답을 구성하도록 변경했다.

그 결과, API 1건당 평균 응답 시간은 약 0.3초 수준으로 단축되었고, Redis 호출 수는 6회 → 1회로 약 83% 감소하였다. 또한, 전체 API 응답 속도는 기존 대비 최대 42% 단축되었다.


